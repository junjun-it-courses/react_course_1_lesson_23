# useState

Хук useState(), отвечает за работу с состоянием внутри компонента. В отличие от 
классовых компонентов, хук занимается сразу всем: инициализацией, обновлением
и предоставляет доступ к состоянию. Пример вызова:

> lesson-files/hooks/src/components/HookComponent.jsx

```
// Не забываем импортировать
import React, { useState } from 'react';

const Example = () => {
  // Имена возвращаемых значений выбираются произвольно
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Вы нажали {count} раз(а)</p>
      <button onClick={() => setCount(count + 1)}>
        Нажми меня
      </button>
    </div>
  );
};
```


useState() принимает на вход начальное состояние и возвращает массив из двух
значений: текущего значения состояния и функции, которая обновляет состояние.
Кроме того, что такой код выглядит необычно, еще есть вопросы к его работе.
Как мы знаем, компонент, как функция, вызывается на каждую перерисовку и логично
предположить что значением count всегда будет 0 из-за постоянных вызовов
useState(). Как это ни странно, но такого не произойдет. Хуки устроены гораздо
хитрее, чем это кажется на первый взгляд. Да, функция useState() действительно
вызывается каждый раз при перерисовке, но внутри она знает об этом и учитывает
в работе. Начальное состояние задается ровно один раз и дальше не используется.
Само состояние хранится где-то внутри и скрыто от прямого изменения. Единственный
способ повлиять на него – вызвать вернувшуюся функцию с передачей нового состояния.

Функцию setCount() можно вызывать в любом месте, например в коллбеке, как в 
примере выше, или в другом компоненте, куда эта функция может быть передана.
В этом смысле, все работает так как и в классах.

В отличие от this.setState(), хук useState() не сливает старое состояние с новым:

```
// Где-то в колбеке
setTodos([{ text: 'Помыть посуду' }]);

// На следующем цикле
// Пропало начальное значение
console.log(todos); // => [{ text: 'Помыть посуду' }]
```

Хуки могут использоваться больше одного раза если это нужно. Мы легко можем
создать несколько переменных состояния:

```
const ExampleWithManyStates = () => {
  const [age, setAge] = useState(42);
  const [schoolName, setSchoolName] = useState('Хекслет');
  const [todos, setTodos] = useState([{ text: 'Изучить хуки' }]);
  // ...
};
```

## Сколько создавать переменных состояния?

Технически мы можем поместить все в одну переменную, как это делалось в классах,
но с хуками в этом нет большой необходимости. Более того, состоянием в рамках
одного компонента проще управлять когда оно разделено по частям, которые
обновляются совместно. 

Например:


```
const [position, setPosition] = useState({ left: 0, top: 0 });
const [size, setSize] = useState({ width: 100, height: 100 });
```